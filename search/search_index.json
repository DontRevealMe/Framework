{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Framework Docs This where the DontRevealMe's framework documentation is. Why There currently is no true compelling reason to use this framework over another. It's more of preferences.","title":"Home"},{"location":"#welcome-to-framework-docs","text":"This where the DontRevealMe's framework documentation is.","title":"Welcome to Framework Docs"},{"location":"#why","text":"There currently is no true compelling reason to use this framework over another. It's more of preferences.","title":"Why"},{"location":"API/Classes/Queue/","text":"Queue Class The queue class is a class that makes the creation and handling of queues much easier. It also has performance improvements by yielding the couroutine loop when it has finished all of the queue. API Properties Property Name Description table Queue Table containing the queue. internal Signal _wakeUp Wakes up the queue coroutine. internal Coroutine _updateCoroutine The couroutine function that is in charge of managing the queue. Methods Method Name Description void :Dequeue( integer index) Removes a specific index from the queue. void :Enqueue( Variant value) Adds passed value into the queue. void :SetUpdater( Function updater) Function that will be called each time the next slot in the queue is ready. Function will be given the current front most value.","title":"Queue"},{"location":"API/Classes/Queue/#queue-class","text":"The queue class is a class that makes the creation and handling of queues much easier. It also has performance improvements by yielding the couroutine loop when it has finished all of the queue.","title":"Queue Class"},{"location":"API/Classes/Queue/#api","text":"","title":"API"},{"location":"API/Classes/Queue/#properties","text":"Property Name Description table Queue Table containing the queue. internal Signal _wakeUp Wakes up the queue coroutine. internal Coroutine _updateCoroutine The couroutine function that is in charge of managing the queue.","title":"Properties"},{"location":"API/Classes/Queue/#methods","text":"Method Name Description void :Dequeue( integer index) Removes a specific index from the queue. void :Enqueue( Variant value) Adds passed value into the queue. void :SetUpdater( Function updater) Function that will be called each time the next slot in the queue is ready. Function will be given the current front most value.","title":"Methods"},{"location":"API/Classes/MessagingService/ChannelListener/","text":"ChannelListener Listens onto MessagingService channels. This class is not commonly used but is still documented. It's mainly internal. API Properties Property Name Description string Name Name of what channel the listener is listening onto. Signal OnRecievedSignal Signal will fire when the channel recieves a packet. Maid _maid Maid class to help clean up the listener if the Destroy method is called. RBXScriptConnection Connection Connection that is connected to SubscribeAsync. Methods Method Name Description RBXScriptConnection :Connect( bool getCompleteOnly, Function callbackFunction) Connects the function to the listener. void :Destroy() Destroys the listener class.","title":"ChannelListener"},{"location":"API/Classes/MessagingService/ChannelListener/#channellistener","text":"Listens onto MessagingService channels. This class is not commonly used but is still documented. It's mainly internal.","title":"ChannelListener"},{"location":"API/Classes/MessagingService/ChannelListener/#api","text":"","title":"API"},{"location":"API/Classes/MessagingService/ChannelListener/#properties","text":"Property Name Description string Name Name of what channel the listener is listening onto. Signal OnRecievedSignal Signal will fire when the channel recieves a packet. Maid _maid Maid class to help clean up the listener if the Destroy method is called. RBXScriptConnection Connection Connection that is connected to SubscribeAsync.","title":"Properties"},{"location":"API/Classes/MessagingService/ChannelListener/#methods","text":"Method Name Description RBXScriptConnection :Connect( bool getCompleteOnly, Function callbackFunction) Connects the function to the listener. void :Destroy() Destroys the listener class.","title":"Methods"},{"location":"API/Classes/MessagingService/Package/","text":"Package Packages contain multiple packets classes. API Properties Property Name Description string Name Contains the name of package. table Packets Contains all the packets stored. number Size Size of the all the packets. Methods Method Name Description void :Destroy() Destroys the class. void :FireAllResponses( Variant data) Fires a packet response signals. number :GetSize() Gets the size of all the packet datas. bool :AddPacket( Packet packet, bool check) Adds a packet to the package. If check is set to true, it will check if there is room or not and if there isn't, it will return false. void :Send( bool dontReplace) Sends the package and puts it in the SendQueue. If dontReplace is set to true, it won't automically replaced the package in currentlyBoxing.","title":"Package"},{"location":"API/Classes/MessagingService/Package/#package","text":"Packages contain multiple packets classes.","title":"Package"},{"location":"API/Classes/MessagingService/Package/#api","text":"","title":"API"},{"location":"API/Classes/MessagingService/Package/#properties","text":"Property Name Description string Name Contains the name of package. table Packets Contains all the packets stored. number Size Size of the all the packets.","title":"Properties"},{"location":"API/Classes/MessagingService/Package/#methods","text":"Method Name Description void :Destroy() Destroys the class. void :FireAllResponses( Variant data) Fires a packet response signals. number :GetSize() Gets the size of all the packet datas. bool :AddPacket( Packet packet, bool check) Adds a packet to the package. If check is set to true, it will check if there is room or not and if there isn't, it will return false. void :Send( bool dontReplace) Sends the package and puts it in the SendQueue. If dontReplace is set to true, it won't automically replaced the package in currentlyBoxing.","title":"Methods"},{"location":"API/Classes/MessagingService/Packet/","text":"Packet Packets are used to hold data for MessagingService.There is currently no documentation for the packet class that is created by the packet module. Notice This is a recieving packet ie the packet that is passed through in a callback function. The packet that is created by a class hasn't been documented yet. API Properties Property Name Description table Data Contains data that the packet holds string Name If the packet is sent through a subchannel, it will have a name property. string UID If the packet is a segment, it will have a unique ID. string Order If the packet is a segment, it will have a string that contains it's order ie 1/3 .","title":"Packet"},{"location":"API/Classes/MessagingService/Packet/#packet","text":"Packets are used to hold data for MessagingService.There is currently no documentation for the packet class that is created by the packet module. Notice This is a recieving packet ie the packet that is passed through in a callback function. The packet that is created by a class hasn't been documented yet.","title":"Packet"},{"location":"API/Classes/MessagingService/Packet/#api","text":"","title":"API"},{"location":"API/Classes/MessagingService/Packet/#properties","text":"Property Name Description table Data Contains data that the packet holds string Name If the packet is sent through a subchannel, it will have a name property. string UID If the packet is a segment, it will have a unique ID. string Order If the packet is a segment, it will have a string that contains it's order ie 1/3 .","title":"Properties"},{"location":"API/Internal/","text":"Internal Library This contains all documentation for internal libraries.","title":"Internal"},{"location":"API/Internal/#internal-library","text":"This contains all documentation for internal libraries.","title":"Internal Library"},{"location":"API/Libraries/DataStoreService/","text":"DataStoreService Accessibility This library can only be accessed by the server Warning DataStoreService will soon be overhauled . So there isn't documentation for it. Any documentation that does appear, it will be for the overhauled version. API Properties Property Name Description table _cache [internal] Contains cache of all DataStores. Functions Function Name Description Returns NormalDataStore / OrderedBackups / OrderedDataStore .new( string name, string key, string callingMethod) Creates a new DataStore class. DataStore / OrderedBackup / OrderedDataStore .new NormalDataStore / OrderedBackups / OrderedDataStore .new( string name, string key, string callingMethod) Constructor function to create a new class. It's class depends on your callingMethod argument. Calling Methods NormalDataStores This is your average normal DataStore saving system. It uses :UpdateAsync() to overwrite existing keys. OrderedDataStores This is your average OrderedDataStore saving system. Uses Roblox's OrderedDataStores. OrderedBackups Notice It's highly reccomended you use this method to store player data as it drastically lowers the risk of data loss. Using NormalDataStores might be better suited for non-player data. This uses Berezaa's saving method. The idea is that you'll make a new key each time you save and store the key that you used to save it in a OrderedDataStore. When you need to retrive the key, you'll use :GetSortedAsync() to retrive the latest the key and use that to get the lastest data. This is all done automatically when you pass through \"OrderedBackups\" as your savingMethod.","title":"DataStoreService"},{"location":"API/Libraries/DataStoreService/#datastoreservice","text":"Accessibility This library can only be accessed by the server Warning DataStoreService will soon be overhauled . So there isn't documentation for it. Any documentation that does appear, it will be for the overhauled version.","title":"DataStoreService"},{"location":"API/Libraries/DataStoreService/#api","text":"","title":"API"},{"location":"API/Libraries/DataStoreService/#properties","text":"Property Name Description table _cache [internal] Contains cache of all DataStores.","title":"Properties"},{"location":"API/Libraries/DataStoreService/#functions","text":"Function Name Description Returns NormalDataStore / OrderedBackups / OrderedDataStore .new( string name, string key, string callingMethod) Creates a new DataStore class. DataStore / OrderedBackup / OrderedDataStore","title":"Functions"},{"location":"API/Libraries/DataStoreService/#new","text":"NormalDataStore / OrderedBackups / OrderedDataStore .new( string name, string key, string callingMethod) Constructor function to create a new class. It's class depends on your callingMethod argument.","title":".new"},{"location":"API/Libraries/DataStoreService/#calling-methods","text":"","title":"Calling Methods"},{"location":"API/Libraries/DataStoreService/#normaldatastores","text":"This is your average normal DataStore saving system. It uses :UpdateAsync() to overwrite existing keys.","title":"NormalDataStores"},{"location":"API/Libraries/DataStoreService/#ordereddatastores","text":"This is your average OrderedDataStore saving system. Uses Roblox's OrderedDataStores.","title":"OrderedDataStores"},{"location":"API/Libraries/DataStoreService/#orderedbackups","text":"Notice It's highly reccomended you use this method to store player data as it drastically lowers the risk of data loss. Using NormalDataStores might be better suited for non-player data. This uses Berezaa's saving method. The idea is that you'll make a new key each time you save and store the key that you used to save it in a OrderedDataStore. When you need to retrive the key, you'll use :GetSortedAsync() to retrive the latest the key and use that to get the lastest data. This is all done automatically when you pass through \"OrderedBackups\" as your savingMethod.","title":"OrderedBackups"},{"location":"API/Libraries/MessagingService/","text":"MessagingService Accessibility This library can only be accessed by the server Manages the sending and handling of packets across server. API Limitations This is measured using HttpService:JSONEncode() . Property Limit Packet size 800 characters Package size 950 characters Warning If your packets exceeds the packet size limit, not the data size limit, expect all other packets to be delayed by math.ceil(length / 800) seconds. Length is calculate by using HttpService:JSONEncode(). Properties None. Functions Function Name Description Returns Promise :SendAsync( table data, string name, bool subChannels= nil [optional] ) Sends data to other servers. RBXScriptConnection RBXScriptConnection :Listen( string name, bool getComplete= true [optional] , bool subChannels= true [optional] , Function callback) Listens for a specific channel. TopicListener :SendAsync Promise :SendAsync( table data, string name, bool subChannels= false [optional] ) Sends data to other servers. subChannels argument is used to determine whether or not the packet will be sent through a subchannel channel. Listen RBXScriptConnection :Listen( string name, bool getComplete= true [optional] , bool subChannels= true [optional] , Function callback) Listens for a specfiic channel. getComplete argument means it will only recieve complete packets and not segment packets. subChannels argument means whether or not the listener will listen onto subchannels instead of regular channels. Callback will be passed arguments such as data , timeSent , and packet . Callback arguments Everytime a packet is sent, the callback function will be passed the following arguments: Argument Description table data The data of the packet. number timeSent The UNIX time of when the packet was sent. Packet packet The packet itself. It may contain information about the packet's UID, topic, and etc... See Packet for more info How it works Packets Packets are an internal OOP class which are comprised of properties that contain it's topic, data, and unique ID if the packet is a segment. Packages Packages contain a group of packets and will be sent automically after a 1 second it has been created or they have reached the package size limit. Segments In the odd case there is a packet larger than 800 characters, the server will attempt to split the packet data up into serveral segments. These segment packets will be sent through. The con of this is that it may delay publishes by several seconds which is why it's reccomended that you try to keep data below 800 characters. SubChannels The idea of SubChannel is to reduce the amount of Channels being listened onto. This means you could have 3 SubChannel Channels but have 10 packets firing through 10 channels. The cons of a SubChannels is that they may have less capacity vs a normal channel since they also need to store the topic name.","title":"MessagingService"},{"location":"API/Libraries/MessagingService/#messagingservice","text":"Accessibility This library can only be accessed by the server Manages the sending and handling of packets across server.","title":"MessagingService"},{"location":"API/Libraries/MessagingService/#api","text":"","title":"API"},{"location":"API/Libraries/MessagingService/#limitations","text":"This is measured using HttpService:JSONEncode() . Property Limit Packet size 800 characters Package size 950 characters Warning If your packets exceeds the packet size limit, not the data size limit, expect all other packets to be delayed by math.ceil(length / 800) seconds. Length is calculate by using HttpService:JSONEncode().","title":"Limitations"},{"location":"API/Libraries/MessagingService/#properties","text":"None.","title":"Properties"},{"location":"API/Libraries/MessagingService/#functions","text":"Function Name Description Returns Promise :SendAsync( table data, string name, bool subChannels= nil [optional] ) Sends data to other servers. RBXScriptConnection RBXScriptConnection :Listen( string name, bool getComplete= true [optional] , bool subChannels= true [optional] , Function callback) Listens for a specific channel. TopicListener","title":"Functions"},{"location":"API/Libraries/MessagingService/#sendasync","text":"Promise :SendAsync( table data, string name, bool subChannels= false [optional] ) Sends data to other servers. subChannels argument is used to determine whether or not the packet will be sent through a subchannel channel.","title":":SendAsync"},{"location":"API/Libraries/MessagingService/#listen","text":"RBXScriptConnection :Listen( string name, bool getComplete= true [optional] , bool subChannels= true [optional] , Function callback) Listens for a specfiic channel. getComplete argument means it will only recieve complete packets and not segment packets. subChannels argument means whether or not the listener will listen onto subchannels instead of regular channels. Callback will be passed arguments such as data , timeSent , and packet .","title":"Listen"},{"location":"API/Libraries/MessagingService/#callback-arguments","text":"Everytime a packet is sent, the callback function will be passed the following arguments: Argument Description table data The data of the packet. number timeSent The UNIX time of when the packet was sent. Packet packet The packet itself. It may contain information about the packet's UID, topic, and etc... See Packet for more info","title":"Callback arguments"},{"location":"API/Libraries/MessagingService/#how-it-works","text":"","title":"How it works"},{"location":"API/Libraries/MessagingService/#packets","text":"Packets are an internal OOP class which are comprised of properties that contain it's topic, data, and unique ID if the packet is a segment.","title":"Packets"},{"location":"API/Libraries/MessagingService/#packages","text":"Packages contain a group of packets and will be sent automically after a 1 second it has been created or they have reached the package size limit.","title":"Packages"},{"location":"API/Libraries/MessagingService/#segments","text":"In the odd case there is a packet larger than 800 characters, the server will attempt to split the packet data up into serveral segments. These segment packets will be sent through. The con of this is that it may delay publishes by several seconds which is why it's reccomended that you try to keep data below 800 characters.","title":"Segments"},{"location":"API/Libraries/MessagingService/#subchannels","text":"The idea of SubChannel is to reduce the amount of Channels being listened onto. This means you could have 3 SubChannel Channels but have 10 packets firing through 10 channels. The cons of a SubChannels is that they may have less capacity vs a normal channel since they also need to store the topic name.","title":"SubChannels"},{"location":"API/Libraries/Queue/","text":"Queue Creates a queue class. API Functions Function Name Description Returns .new() Creates a new queue class Returns a queue class","title":"Queue"},{"location":"API/Libraries/Queue/#queue","text":"Creates a queue class.","title":"Queue"},{"location":"API/Libraries/Queue/#api","text":"","title":"API"},{"location":"API/Libraries/Queue/#functions","text":"Function Name Description Returns .new() Creates a new queue class Returns a queue class","title":"Functions"},{"location":"API/Libraries/MessagingService/SubChannelsManager/","text":"","title":"SubChannelsManager"},{"location":"API/Sides/Client/","text":"Client The client side is located in StarterPlayerScripts. It holds all the modules that are to only be accessed and ran on the client side. Attention During gameplay, the client side would be placed in the player's PlayerScript. Accessing StarterPlayerScript will not modify the player's module scripts. If you wanna access a module, use the loader.","title":"Client"},{"location":"API/Sides/Client/#client","text":"The client side is located in StarterPlayerScripts. It holds all the modules that are to only be accessed and ran on the client side. Attention During gameplay, the client side would be placed in the player's PlayerScript. Accessing StarterPlayerScript will not modify the player's module scripts. If you wanna access a module, use the loader.","title":"Client"},{"location":"API/Sides/Server/","text":"Server The server side is located in ServerStorage. It holds all the modules that are to only be accessed and ran on the server side.","title":"Server"},{"location":"API/Sides/Server/#server","text":"The server side is located in ServerStorage. It holds all the modules that are to only be accessed and ran on the server side.","title":"Server"},{"location":"API/Sides/Shared/","text":"Shared Shared side is a side that is shared between the server and client(s). Attention Changes made from the server will replicate over to all clients, but if the client tries to change the value of a module, it won't replicate over to the server or other clients.","title":"Shared"},{"location":"API/Sides/Shared/#shared","text":"Shared side is a side that is shared between the server and client(s). Attention Changes made from the server will replicate over to all clients, but if the client tries to change the value of a module, it won't replicate over to the server or other clients.","title":"Shared"},{"location":"Guide/Installation/","text":"Installation guide Rojo This is currently the only way of installing the framework. Install Rojo Download the Framework Run Rojo in the same folder as the Framework You're ready!","title":"Installation Guide"},{"location":"Guide/Installation/#installation-guide","text":"","title":"Installation guide"},{"location":"Guide/Installation/#rojo","text":"This is currently the only way of installing the framework. Install Rojo Download the Framework Run Rojo in the same folder as the Framework You're ready!","title":"Rojo"},{"location":"Guide/Roadmap/","text":"Roadmap \"Planned\" roadmap for the Framework. These time frames will most likely either be completed way too soon or completed way too late. Soon This month or next. Overhaul DataStoreService Overhaul Ambassador Document major parts of the API Near future 2+ months Look into a more comamnd line like loading method ie loader(\"MessagingService --useChannels\") A overhaul of the modules to add methods such as :Init(), :OnStep(), and etc... Full documentation of the API including internal API Add more general purpose modules such as a BanService [Unlikely] ChatTags library [Unlikely] New installation methods for the framework Copy and paste code into Roblox Studio's command line to install the framework Auto-update a model Auto-updater script Future 6+ months Anti-exploit that will check for character movement exploits ie fly hacks, speed hacks, tp hacks, and etc... OOP library [Unlikely]","title":"Roadmap"},{"location":"Guide/Roadmap/#roadmap","text":"\"Planned\" roadmap for the Framework. These time frames will most likely either be completed way too soon or completed way too late.","title":"Roadmap"},{"location":"Guide/Roadmap/#soon","text":"This month or next. Overhaul DataStoreService Overhaul Ambassador Document major parts of the API","title":"Soon"},{"location":"Guide/Roadmap/#near-future","text":"2+ months Look into a more comamnd line like loading method ie loader(\"MessagingService --useChannels\") A overhaul of the modules to add methods such as :Init(), :OnStep(), and etc... Full documentation of the API including internal API Add more general purpose modules such as a BanService [Unlikely] ChatTags library [Unlikely] New installation methods for the framework Copy and paste code into Roblox Studio's command line to install the framework Auto-update a model Auto-updater script","title":"Near future"},{"location":"Guide/Roadmap/#future","text":"6+ months Anti-exploit that will check for character movement exploits ie fly hacks, speed hacks, tp hacks, and etc... OOP library [Unlikely]","title":"Future"},{"location":"Guide/Contributing/DocumentationStandards/","text":"Documentation Format This contains everything you'll need for the documentation standards. What you'll need MarkdownLint A text editor that supports MarkdownLint Documenting a method/function Generally, methods and functions will be documented inside of tables. We try to follow Roblox's standard as much as possible here. Any extra info on the argument should be placed after it. ``returnType`` :MyFunction(``string`` myArgument, ``Variant`` myOptionalVariant=``defaultValue`` ``[optional]``) ``[yields]`` For example: Vector3 :GetSize( Instance model, Variant myOptional= 3 [optional] ) number :GetAsync( string scope, integer , integer amount= 4 [optional] ) [yields] How to document a library Libraries generally follow a documentation strucutre of: # TITLE DESCRIPTION ## API | Property Name | Description | |---------------|-------------| | ``type`` myName ``[internal]`` | ... | | Function Name | Description | Returns | |---------------|-------------|---------| | ``returnType`` myFunction(...) ``[internal]`` ``[optional]`` | ... | If you have more information on the return type, put it here. | Include anything else such as examples after the API section. Anything after should be titled too using ## . How to document a class Documenting classes is similiar to documenting libraries but we change the names up. # TITLE DESCRIPTION ## API | Property Nane | Description | |---------------|-------------| | Method Name | Description | Returns | |-------------|-------------|---------| Same ideas as documenting libraries. If you want to add more, add it after the API section ie code examples. Stuff that should appear before the API section should be stuff like limitations, warnings, and etc... It's also optional to add more information such as a more detailed section describing each method/function: ### Functions #### :GetAsync() | ``table`` :GetAsync(``string`` url) ``[yields]`` | |-------------------------------------| | Gets the body of the url. |","title":"Documentation Standards"},{"location":"Guide/Contributing/DocumentationStandards/#documentation-format","text":"This contains everything you'll need for the documentation standards.","title":"Documentation Format"},{"location":"Guide/Contributing/DocumentationStandards/#what-youll-need","text":"MarkdownLint A text editor that supports MarkdownLint","title":"What you'll need"},{"location":"Guide/Contributing/DocumentationStandards/#documenting-a-methodfunction","text":"Generally, methods and functions will be documented inside of tables. We try to follow Roblox's standard as much as possible here. Any extra info on the argument should be placed after it. ``returnType`` :MyFunction(``string`` myArgument, ``Variant`` myOptionalVariant=``defaultValue`` ``[optional]``) ``[yields]`` For example: Vector3 :GetSize( Instance model, Variant myOptional= 3 [optional] ) number :GetAsync( string scope, integer , integer amount= 4 [optional] ) [yields]","title":"Documenting a method/function"},{"location":"Guide/Contributing/DocumentationStandards/#how-to-document-a-library","text":"Libraries generally follow a documentation strucutre of: # TITLE DESCRIPTION ## API | Property Name | Description | |---------------|-------------| | ``type`` myName ``[internal]`` | ... | | Function Name | Description | Returns | |---------------|-------------|---------| | ``returnType`` myFunction(...) ``[internal]`` ``[optional]`` | ... | If you have more information on the return type, put it here. | Include anything else such as examples after the API section. Anything after should be titled too using ## .","title":"How to document a library"},{"location":"Guide/Contributing/DocumentationStandards/#how-to-document-a-class","text":"Documenting classes is similiar to documenting libraries but we change the names up. # TITLE DESCRIPTION ## API | Property Nane | Description | |---------------|-------------| | Method Name | Description | Returns | |-------------|-------------|---------| Same ideas as documenting libraries. If you want to add more, add it after the API section ie code examples. Stuff that should appear before the API section should be stuff like limitations, warnings, and etc... It's also optional to add more information such as a more detailed section describing each method/function: ### Functions #### :GetAsync() | ``table`` :GetAsync(``string`` url) ``[yields]`` | |-------------------------------------| | Gets the body of the url. |","title":"How to document a class"}]}